<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Yarte 0.15</title>
        
        <meta name="robots" content="noindex" />
        

        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link href="https://fonts.googleapis.com/css?family=Open+Sans:300italic,400italic,600italic,700italic,800italic,400,300,600,700,800" rel="stylesheet" type="text/css">
        <link href="https://fonts.googleapis.com/css?family=Source+Code+Pro:500" rel="stylesheet" type="text/css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        

        
    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "light" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded "><a href="description.html"><strong aria-hidden="true">1.</strong> Description</a></li><li class="chapter-item expanded "><a href="getting_started.html"><strong aria-hidden="true">2.</strong> Getting started</a></li><li class="chapter-item expanded "><a href="config.html"><strong aria-hidden="true">3.</strong> Config</a></li><li class="chapter-item expanded "><a href="meta-programming.html"><strong aria-hidden="true">4.</strong> Meta programming</a></li><li class="chapter-item expanded "><a href="templating/templating.html"><strong aria-hidden="true">5.</strong> Templating</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="templating/comment.html"><strong aria-hidden="true">5.1.</strong> Comments</a></li><li class="chapter-item expanded "><a href="templating/helpers/helpers.html"><strong aria-hidden="true">5.2.</strong> Helpers</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="templating/helpers/conditional.html"><strong aria-hidden="true">5.2.1.</strong> Conditional</a></li><li class="chapter-item expanded "><a href="templating/helpers/each.html"><strong aria-hidden="true">5.2.2.</strong> Each</a></li><li class="chapter-item expanded "><a href="templating/helpers/with.html"><strong aria-hidden="true">5.2.3.</strong> With</a></li></ol></li><li class="chapter-item expanded "><a href="templating/at-helpers/at-helpers.html"><strong aria-hidden="true">5.3.</strong> @Helpers</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="templating/at-helpers/json.html"><strong aria-hidden="true">5.3.1.</strong> Json</a></li></ol></li><li class="chapter-item expanded "><a href="templating/html.html"><strong aria-hidden="true">5.4.</strong> HTML</a></li><li class="chapter-item expanded "><a href="templating/let.html"><strong aria-hidden="true">5.5.</strong> Let</a></li><li class="chapter-item expanded "><a href="templating/partial.html"><strong aria-hidden="true">5.6.</strong> Partial</a></li><li class="chapter-item expanded "><a href="templating/raw.html"><strong aria-hidden="true">5.7.</strong> Raw</a></li><li class="chapter-item expanded "><a href="templating/rust_code.html"><strong aria-hidden="true">5.8.</strong> Rust code</a></li><li class="chapter-item expanded "><a href="templating/super_scope.html"><strong aria-hidden="true">5.9.</strong> Super scope</a></li><li class="chapter-item expanded "><a href="templating/whitespace_control.html"><strong aria-hidden="true">5.10.</strong> Whitespace control</a></li></ol></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                        
                    </div>

                    <h1 class="menu-title">Yarte 0.15</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        
                    </div>
                </div>

                
                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" name="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1><a class="header" href="#description" id="description">Description</a></h1>
<p>Yarte stands for <strong>Y</strong>et <strong>A</strong>nother <strong>R</strong>ust <strong>T</strong>emplate <strong>E</strong>ngine, 
is the fastest template engine. Uses a Handlebars-like syntax, 
well known and intuitive for most developers. Yarte is an optimized, and easy-to-use 
rust crate, with which developers can create logic around their 
HTML templates using using conditionals, loops, rust code 
and using templates composition with partials.</p>
<p>Yarte is intended to be more than just a substitute for PHP, I want to encompass 
all GUI types with a front end based on Handlebars, HTML5 and Rust.</p>
<p>The process is tedious and very complicated, so certain expendable parts are omitted 
and will be subject to several refactors before first release.</p>
<h2><a class="header" href="#derive-attributes" id="derive-attributes">Derive attributes</a></h2>
<ul>
<li><code>src</code>: template sources</li>
<li><code>path</code>: path to sources relative to template directory</li>
<li><code>print</code>: <code>all</code>, <code>ast</code> or <code>code</code> display debug info. Overridden by config file print option.</li>
<li><code>recursion</code>: <code>default: 128</code> Set limit of partial deep, can produce stackoverflow at compile time</li>
</ul>
<h2><a class="header" href="#rules" id="rules">Rules</a></h2>
<ul>
<li>Only use <code>}}</code> or <code>{{\</code> for expressions or blocks (If you want to use them in any place, you are free to implement a tokenizer that includes the syntax of yarte and rust and do PR)</li>
<li>Default template extension is <code>hbs</code>, since it includes much of the language (If you want to better IDE support, you are free to write a plugin with <code>yrt</code> extension)</li>
</ul>
<h1><a class="header" href="#getting-started" id="getting-started">Getting started</a></h1>
<p>As yarte files are not compiler-specific, you have to add: </p>
<h4><a class="header" href="#cargotoml" id="cargotoml"><code>Cargo.toml</code></a></h4>
<pre><code class="language-toml">[build-dependencies]
yarte = &quot;0.15&quot;
</code></pre>
<h4><a class="header" href="#buildrs" id="buildrs"><code>build.rs</code></a></h4>
<pre><pre class="playpen"><code class="language-rust">fn main() {
    yarte::recompile::when_changed();
}
</code></pre></pre>
<p>In order to recompile when something in the template directory changed ;</p>
<p>Yarte templates look like regular text, with embedded yarte expressions. 
Create a simple Yarte template called <code>hello.hbs</code> in your template directory.</p>
<pre><code class="language-handlebars">&lt;div class=&quot;entry&quot;&gt;
  &lt;h1&gt;{{title}}&lt;/h1&gt;
  &lt;div class=&quot;body&quot;&gt;
    {{body}}
  &lt;/div&gt;
&lt;/div&gt;
</code></pre>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>use yarte::*;

struct Card&lt;'a&gt; {
    title: &amp;'a str,
    body: &amp;'a str,
}

fn foo() -&gt; String {
    let my_card = Card {
        title: &quot;My Title&quot;,
        body: &quot;My Body&quot;,
    };

    auto!(ywrite_html!(String, &quot;{{&gt; hello my_card }}&quot;))
}
<span class="boring">}
</span></code></pre></pre>
<p>will write in the formatter the following string:</p>
<pre><code class="language-html">&lt;div class=&quot;entry&quot;&gt;
  &lt;h1&gt; My Title &lt;/h1&gt;
  &lt;div class=&quot;body&quot;&gt;
    My Body
  &lt;/div&gt;
&lt;/div&gt;
</code></pre>
<h1><a class="header" href="#config-file" id="config-file">Config File</a></h1>
<p>Right now a Yarte configuration file can have the following:</p>
<ul>
<li>
<p><strong><code>main</code></strong> (general configuration - optional): with attribute</p>
<ul>
<li><strong><code>dir</code></strong>: name of template directory. If no value is given, a default directory
<strong><code>templates</code></strong> will be used. If the defined directory is not found, an error
will prompt.</li>
<li><strong><code>debug</code></strong>: type of output of debug mode. The code and/or  ast generated by  Yarte
can be visualize, to do so, at most one of three possible values has to be given:
<code>code</code>, <code>ast</code>, or <code>all</code>.</li>
</ul>
</li>
<li>
<p><strong><code>partials</code></strong> (partials aliasing - optional): each entry must be of the type
<code>name_alias = &quot;./alias/path/&quot;</code>, where <code>./</code> makes reference to <code>dir</code> value. Path
must exist, or error will be prompt. If the tag <code>partials</code> doesn't exist no aliasing
will be possible.</p>
</li>
<li>
<p><strong><code>debug</code></strong> (debugging configuration - optional): in order to visualize clearly generated code
in a debugging environment Yarte gives it a tabulated format, and the possibility
to see the number line use a color theme. Options are the following:</p>
<ul>
<li><strong><code>number_line</code></strong> (default:  <code>false</code>): Boolean, if set to <code>true</code> number lines will appear
in debug-mode.</li>
<li><strong><code>theme</code></strong> (default: <code>zenburn</code>): String, color theme used in debugging environment.
Possible values are:
<ul>
<li><code>DarkNeon</code>,</li>
<li><code>GitHub</code>,</li>
<li><code>Monokai Extended</code>,</li>
<li><code>Monokai Extended Bright</code>,</li>
<li><code>Monokai Extended Light</code>,</li>
<li><code>Monokai Extended Origin</code>,</li>
<li><code>OneHalfDark</code>,</li>
<li><code>OneHalfLight</code>,</li>
<li><code>Sublime Snazzy</code>,</li>
<li><code>TwoDark</code>,</li>
<li><code>zenburn</code></li>
</ul>
</li>
<li><strong><code>grid</code></strong> (default:  <code>false</code>): Boolean</li>
<li><strong><code>header</code></strong> (default:  <code>false</code>): Boolean</li>
<li><strong><code>paging</code></strong> (default:  <code>false</code>): Boolean</li>
<li><strong><code>short</code></strong> (default:  <code>true</code>): Boolean, if set to <code>false</code> to verbose</li>
</ul>
</li>
</ul>
<h3><a class="header" href="#example-of-a-config-file" id="example-of-a-config-file">Example of a config file</a></h3>
<pre><code class="language-toml">[main]
dir = &quot;templates&quot;
debug = &quot;all&quot;

[partials]
alias = &quot;./deep/more/deep&quot;

[debug]
theme = &quot;zenburn&quot;
number_line = true
grid = true
header = true
paging = false
short = false
</code></pre>
<p>With this configuration, the user can call <code>alias</code> in a partial instance with
<code>{{&gt; alias context}}</code> or <code>{{&gt; alias}}</code> if the current context is well defined.</p>
<h1><a class="header" href="#meta-programming" id="meta-programming">Meta programming</a></h1>
<p>Yarte incorporates a meta programming system parallel to Rust's. 
Which means that it evaluates all Rust expressions at compilation 
time and together with the partials and the partials block create 
complex compilations in which you can use recursion, modules, 
conditional, loops, arrays and ranges.</p>
<p>The methods that can be used are listed in the documentation for <a href="https://docs.rs/v_eval"><code>v_eval</code></a>.</p>
<p>All undefined variables at compile time will be <code>None</code> in the evaluator.</p>
<h1><a class="header" href="#templating" id="templating">Templating</a></h1>
<p>Yarte uses opening characters <code>{{</code> and closing 
characters <code>}}</code> to parse the inside depending 
on the feature used. Most of the features are 
defined by Handlebars such as paths, comments, 
html, helpers and partials. Others such as 
adding rust code to a template, are obviously 
defined by Yarte. Each of these features have
a symbol associated to it (<code># { R &gt;</code>) that is
added after the opening characters, for example
<code>{{#</code> used for helpers. If no symbol is added 
Yarte will interpret  inside code as a valid 
rust expression.</p>
<p>Let's say we want to use the following template <code>template.html</code></p>
<pre><code class="language-html">&lt;h1&gt; Hello, {{name}}! &lt;/h1&gt;
</code></pre>
<p>Now we create a struct with the variable <code>name</code></p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>#[derive(Template)]
#[template(path = &quot;template.html&quot;)]
struct HelloTemplate&lt;'a&gt; {
    name: &amp;'a str,
}
<span class="boring">}
</span></code></pre></pre>
<p>If we now render the template with <code>&quot;world&quot;</code> as value of <code>name</code>,</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>HelloTemplate { 
    name: &quot;world&quot; 
}
.call().unwrap()
<span class="boring">}
</span></code></pre></pre>
<h1><a class="header" href="#comments" id="comments">Comments</a></h1>
<p>In order to add comments to your Yarte code use <code>{{!--</code> or <code>{{!</code> after the opening templating 
tag and use <code>--!}}</code> or <code>!}}</code>, respectively, as a closing clause.</p>
<pre><code class="language-handlebars">{{!   Comments can be written  !}}
{{!--  in two different ways --!}}
</code></pre>
<p>Comments will appear on the debug output. In release, comments are removed and stream is optimized.
Whitespaces around the comment block will be ignored.</p>
<h1><a class="header" href="#helpers" id="helpers">Helpers</a></h1>
<p>Helpers are given a context and a function to template the context.</p>
<p>Helpers allow the user to create blocks with a pre defined functionality
with certain context. Yarte provides some built-in helpers, but users can
still define theirs.</p>
<h1><a class="header" href="#conditional-helper" id="conditional-helper">Conditional helper</a></h1>
<h2><a class="header" href="#if-helper" id="if-helper">If helper</a></h2>
<p>The conditional helper must start with an <code>if</code> block, followed by the  condition, 
<code>{{#if condition}}</code>, where <code>condition</code> is a valid rust expression (otherwise an 
error will be thrown). Inside an <code>if</code> block, users can use as many <code>else if</code> 
statements as they want  and one <code>else</code> statement to create basic logic in the 
template, without using <code>#</code>, for example, <code>{{else}}</code> or <code>{{else if condotion}}</code>.
In order to close the <code>if</code> block, following the helper syntax, <code>{{/if}}</code> is used.</p>
<pre><code class="language-handlebars">{{#if isLiked}}
  Liked!
{{else if isSeen}}
  Seen!
{{else}}
  Sorry ...
{{/if}}
</code></pre>
<p>In the example above if variable <code>isLiked</code> is interpreted as <code>true</code>, <code>Liked!</code> 
will be parsed. If <code>isLiked</code> is interpreted as <code>false</code> and <code>isSeen</code> as <code>true</code>
then <code>Seen!</code>, otherwise <code>Sorry...</code> will be shown. So having conditional around 
your HTML code is as intuitive as it should be.</p>
<h2><a class="header" href="#unless-helper" id="unless-helper">Unless helper</a></h2>
<p>The <code>unless</code> helper is equivalent to a negated <code>if</code> statement, for that reason, negated <code>unless</code> statements
are not allowed and and error will be prompt.</p>
<pre><code class="language-handlebars">{{#unless isAdministrator-}} 
  Ask administrator.
{{~/unless}}
</code></pre>
<h1><a class="header" href="#each-helper" id="each-helper">Each helper</a></h1>
<p>In order to iterate over a vector of objects, an <code>each</code> helper can be used, with the following syntax:</p>
<pre><code class="language-handlebars">{{#each into_iter}} 
    {{~# if first ~}}
        {{ index }} 
    {{~ else ~}}
        {{ index0 }} 
    {{~/if }} {{ this }} 
{{~/each}}
</code></pre>
<p>Associated variables such as  <code>this</code>, <code>first</code>, <code>index</code>, <code>index0</code> and struct fields are automatically generated
and can be used without declaring them.</p>
<h1><a class="header" href="#with-helper" id="with-helper">With helper</a></h1>
<p>The <code>with</code> helper sets the scope/context to be any specified structure, using syntax
<code>{{#with context}}  {{/with}}</code>.</p>
<p>For example, in the following lines of code we want to set the context inside the <code>with</code> block
to be <code>author</code>, defined in the template instead of the 'main' context.</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>let author = Author {
    name: &quot;J. R. R. Tolkien&quot;
};
<span class="boring">}
</span></code></pre></pre>
<pre><code class="language-handlebars">{{#with author}}
  &lt;p&gt;{{name}}&lt;/p&gt;
{{/with}}
</code></pre>
<p>@helpers are a group of functions implemented on <code>Formatter</code> to format most common template structures.
Are made to avoid reallocation by creating a single output stream on a single highly abstract writer.
Adapt to the language of handlebars by hinting at common expressions headed by the character '@' and 
the name of <code>@helper</code></p>
<p>Per example:</p>
<pre><code class="language-handlebars">{{ @json obj }}
</code></pre>
<h1><a class="header" href="#json" id="json">Json</a></h1>
<p>You can serialize json in your template with <a href="https://docs.serde.rs/serde/trait.Serialize.html"><code>serde::Serialize</code></a></p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>use serde::Serialize;
#[derive(Template)]
#[template(path = &quot;foo&quot;)]
struct Foo&lt;S: Serialize&gt; {
    foo: S
}
<span class="boring">}
</span></code></pre></pre>
<pre><code class="language-handlebars">{{ @json foo }}
</code></pre>
<pre><code class="language-handlebars">{{ @json_pretty foo }}
</code></pre>
<p>Don't escape html characters. </p>
<p>If you are looking to paint it as html text (like &quot;Text&quot; in <code>&lt;h1&gt;Text&lt;/h1&gt;</code>):</p>
<pre><code class="language-handlebars">&lt;h1&gt;{{ serde_json::to_string(&amp;foo).map_err(|_| yarte::Error)? }}&lt;/h1&gt;
</code></pre>
<h1><a class="header" href="#html" id="html">HTML</a></h1>
<p>Yarte HTML-escapes values returned by a <code>{{ expression }}</code>. 
If you don't want Yarte to escape a value, use the 
&quot;triple-stash&quot;, <code>{{{</code>. For example having the following 
struct:</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>let t = CardTemplate {
  title: &quot;All about &lt;p&gt; Tags&quot;,
  body: &quot;&lt;p&gt;This is a post about &amp;lt;p&amp;gt; tags&lt;/p&gt;&quot;
};
<span class="boring">}
</span></code></pre></pre>
<p>and the following template:</p>
<pre><code class="language-handlebars">&lt;div class=&quot;entry&quot;&gt;
  &lt;h1&gt;{{title}}&lt;/h1&gt;
  &lt;div class=&quot;body&quot;&gt;
    {{{body}}}
  &lt;/div&gt;
&lt;/div&gt;
</code></pre>
<p>will result in:</p>
<pre><code class="language-handlebars">&lt;div class=&quot;entry&quot;&gt;
  &lt;h1&gt;All About &amp;lt;p&amp;gt; Tags&lt;/h1&gt;
  &lt;div class=&quot;body&quot;&gt;
    &lt;p&gt;This is a post about &amp;lt;p&amp;gt; tags&lt;/p&gt;
  &lt;/div&gt;
&lt;/div&gt;
</code></pre>
<h1><a class="header" href="#let" id="let">Let</a></h1>
<p>Let statements it can only be used with <code>{{</code> not with <code>{{{</code>, and tries to imitate rust <code>let</code> statement.</p>
<blockquote>
<p>A <code>let</code> statement introduces a new set of variables, given by a pattern. The pattern is followed optionally by a type annotation and then optionally by an initializer expression. When no type annotation is given, the compiler will infer the type, or signal an error if insufficient type information is available for definite inference. Any variables introduced by a variable declaration are visible from the point of declaration until the end of the enclosing block scope.
-- <cite><a href="https://doc.rust-lang.org/reference/statements.html#let-statements">Rust Documentation</a></cite></p>
</blockquote>
<p>Whitespaces before and after the block will be ignored.</p>
<pre><code class="language-handlebars">{{ let doubled = a.iter().map(|x| x * 2).collect::&lt;Vec&lt;_&gt;&gt;() }}
{{ let doubled: Vec&lt;usize&gt; = a.iter().map(|x| x * 2).collect() }}

{{#each doubled ~}}
    {{ this + 1 }}
{{~/each}}
</code></pre>
<p>Inside the expression you can use tuple and slice decomposition, mutability and types:</p>
<pre><code class="language-handlebars">{{ let a = |a: &amp;str| a.repeat(2) }}

{{ let mut a = name.chars() }}

{{ let (mut h, t)  = name.split_at(1) }}
</code></pre>
<h1><a class="header" href="#partial" id="partial">Partial</a></h1>
<p>Partials is  the tool that Yarte provides for  template composition and is a one line expression of type 
<code>{{&gt; partial_path scope attr=val,...}}</code>. The performance <strong>is the same</strong> as writing it and the same as an inline code. 
The partials and their arguments are generated as much as possible within the same <code>&amp;'static str</code>. </p>
<h2><a class="header" href="#path" id="path">Path</a></h2>
<p>The path of a partial is the file path with respect to the file using the partial. Also the <code>config</code> file can be use to 
create aliases (explained in the aliasing section). The partial template file will use the context used in attribute 
scope.</p>
<h2><a class="header" href="#attributes" id="attributes">Attributes</a></h2>
<p>Attributes in partials are assignation where right-hand side if the equal sign must be an expression of type path, 
field, or index. These attributes will be used to reference expression's values and use them inside the partial. 
In a partial, Yarte will first try to look the value in the attributes and if there is no existing attribute, the given 
scope must have it.</p>
<p>*<strong>Note</strong>: In this section we are making reference to attributes which are assignations (not attribute <code>scope</code> or 
<code>path</code>).</p>
<h2><a class="header" href="#scope" id="scope">Scope</a></h2>
<p>Attribute <code>scope</code> is the only attribute that is not an assignation and the only one that a partial must have. </p>
<ul>
<li>
<p>If <code>scope</code> is not given the default context will be the parent's, otherwise  <code>scope</code> can only be an expression of type 
<code>path</code>, <code>field</code>, or <code>index</code>.</p>
</li>
<li>
<p>When attribute <code>scope</code> is given,  the parent scope can not be access using <code>super::</code>.</p>
</li>
</ul>
<p>The following  partial will use file <code>..tempaltes/templates/partial.hbs</code>, and the parent scope to fill he template:</p>
<pre><code class="language-handlebars">{{&gt; ../templates/partial }}
</code></pre>
<p>Now the same file will be used but since a scope is defined, the parent scope will be overriding <code>expr_scope</code>:</p>
<pre><code class="language-handlebars">{{&gt; ../templates expr_scope }}
</code></pre>
<p>Overriding super top scope (<code>self</code> always reference parent scope)
Literals are put inline and pre-escaped when specified (<code>{{ }}</code>).</p>
<pre><code class="language-handlebars">{{&gt; partial var = bar, lit = &quot;foo&quot; }}
</code></pre>
<p>Overriding parent scope and override super (<code>self</code> always reference <code>expr_scope</code>)
Literals are put inline and pre-escaped when specified (<code>{{ }}</code>).</p>
<pre><code class="language-handlebars">{{&gt; partial expr_scope, var = bar, lit = &quot;foo&quot; }}
</code></pre>
<h2><a class="header" href="#partial-block" id="partial-block">Partial Block</a></h2>
<p>This block syntax may also be used to pass templates to the partial, which 
can be executed by the specially named partial, <code>@partial-block</code>. A template of</p>
<pre><code class="language-handlebars">{{#&gt; layout ~}}
  My Content
{{~/layout }}
</code></pre>
<p>with the layout partial containing</p>
<pre><code class="language-handlebars">Site Content {{&gt; @partial-block }}
</code></pre>
<p>Would render</p>
<pre><code>Site Content My Content
</code></pre>
<p>When called in this manner, the block will execute under the context of the partial at the time of the call. 
Depthed paths and block parameters operate relative to the partial block rather than the partial template.</p>
<pre><code class="language-handlebars">{{#each children }}
  {{#&gt; childEntry }}
    {{value}}
  {{/childEntry }}
{{/each }}
</code></pre>
<p>Will render <code>this.value</code> from this template, not the partial.</p>
<h2><a class="header" href="#recursion" id="recursion">Recursion</a></h2>
<blockquote>
<p>TODO</p>
</blockquote>
<h2><a class="header" href="#aliasing" id="aliasing">Aliasing</a></h2>
<p>Aliasing is used to make life easier to developers when referencing to a partial template. This is done in the 
configuration file <code>yarte.toml</code>. </p>
<p>This is explained in more detail in section <a href="templating/../config.html">Config File</a>.</p>
<p>*Note: Aliases make reference to <code>dir</code> in the configuration file.</p>
<h1><a class="header" href="#raw" id="raw">Raw</a></h1>
<p>If escaping Yarte code is ever needed, the <code>{{R }} {{/R }}</code> block can be used and Yarte code
inside the block will be escaped like in the following example: </p>
<pre><code class="language-handlebars">  {{~R }}{{#each example}}{{/each}}   {{~/R }}
</code></pre>
<p>will be render to:</p>
<pre><code class="language-text">{{#each example}}{{/each}}
</code></pre>
<h1><a class="header" href="#rust-code" id="rust-code">Rust code</a></h1>
<p>Yarte provides you with the possibility to use basic raw rust code within 
the HTML files. There are three important facts to take in consideration 
when using rust code in your template, the scope they act upon, resolve ident of variables.</p>
<ul>
<li>
<p>The usage if this feature is limited by its context, meaning that created variables of a scope, will live only in that scope. Also  a valid rust expression, so it will act like Rust.</p>
</li>
<li>
<p>Resolve:</p>
<ul>
<li>
<p>Resolution uses hierarchical nomenclature system, and its most important function is to 'translate' names depending on the context
where it lives. Contexts are defined by the root, helpers, partials, and rust blocks. Created variables in these blocks
will be removed from the scope when block finishes.
If a variable that already existed is redefined, the first will be overwritten by the second one, losing the 
original value. Be careful with pre-defined variables like <code>first</code>, <code>this</code>, <code>index</code>, <code>index0</code>, <code>_index_[0-9]+</code> or <code>_n</code> at tuple context to 
make reference to the n-th item.</p>
</li>
<li>
<p>Constants and static variables must be upper-cased with underscores, <code>N_ITER</code>.</p>
</li>
<li>
<p>Paths of type <code>\*\*::\*\*::\*\*</code> can be use without using reserved word <code>super</code>.</p>
</li>
<li>
<p><code>self</code> refers to the root scope (first parent). Note that in partials this would be the current partial in use.</p>
</li>
<li>
<p>Substitution will take into account <code>super</code>, locals, etc. So keep track of the context created.</p>
</li>
</ul>
</li>
</ul>
<pre><code class="language-handlebars">Hello, {{#each conditions}}
    {{~#if let Some(check) = cond }}
        {{~#if check }}
            {{ let cond = if check { &quot;&amp;foo&quot; } else { &quot;&amp;&quot;} }}
            {{
                if check {
                    cond
                } else if let Some(cond) = key.cond {
                    if cond {
                        &quot;1&quot;
                    } else {
                        &quot;2&quot;
                    }
                } else {
                   &quot;for&quot;
                }
            }}
        {{~ else if let Some(_) = cond }}
        {{~ else if let Some(cond) = key.check }}
            {{~#if cond ~}}
                baa
            {{~/if }}
        {{~ else ~}}
            {{ cond.is_some() }}
        {{~/if~}}
        {{ cond.is_some() &amp;&amp; true }}
    {{~else if let Some(cond) = check }}
        {{~#if cond ~}}
            bar
        {{~/if}}
    {{~ else ~}}
        None
    {{~/if}}
{{~/each}}!
</code></pre>
<pre><code class="language-handlebars">{{ unsafe { s.get_unchecked(0) } }}
</code></pre>
<h1><a class="header" href="#super-scope" id="super-scope">Super scope</a></h1>
<p>In Yarte you will be able to call parents of the actual scope, making parent scopes
available in all child </p>
<pre><code class="language-handlebars">Hello, {{#each this~}}
        {{#each this.as_bytes() ~}}
            {{ super::index0 }} {{ super::super::this[0] }}
        {{~/each }}{{ super::this[0] }}
{{~/each}}!
</code></pre>
<pre><code class="language-handlebars">Hello, {{#each this~}}
    {{#with this}}{{ super::hold }}{{ hold }}{{/with}}
{{~/each}}!
</code></pre>
<pre><code class="language-handlebars">Hello, {{#each this~}}
    {{#with this}}{{ super::hold }}{{ hold }}{{ super::index }}{{/with}}
{{~/each}}!
</code></pre>
<h1><a class="header" href="#whitespace-control" id="whitespace-control">Whitespace control</a></h1>
<p>Yarte provides the possibility to erase the unneeded blanks when templating using the character <code>~</code> 
in any block. Only first white characters and last whitespaces of a block will be ignored. Characters interpreted as whitespaces will as specified in <a href="https://doc.rust-lang.org/reference/whitespace.html">rust</a>.</p>
<p>Let's say 
we have a struct define as follows:</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>#[derive(Template)]
#[template(path = &quot;hello.html&quot;)]
struct CardTemplate&lt;'a&gt; {
    users: Vec&lt;User&lt;'a&gt;&gt;,
}

struct User&lt;'a&gt; {
    valid: bool,
    name: &amp;'a str,
}
<span class="boring">}
</span></code></pre></pre>
<p>and we create a new <code>CardTemplate</code></p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>let t = CardTemplate {
    users: vec![
        User { 
            name: &quot;Tom&quot;,
            valid: true,
        },
    ],
};
<span class="boring">}
</span></code></pre></pre>
<p>Now we will use <code>~</code> in an <code>if</code> statement and ignore unnecessary whitespaces. </p>
<pre><code class="language-handlebars">{{~# each users ~}}
    {{~# if valid ~}}
        &lt;h1&gt;Hello, {{ name }}&lt;/h1&gt;
    {{~/if }}
{{~/each}}
</code></pre>
<p>This will output </p>
<pre><code class="language-text">&lt;h1&gt;Hello, Tom&lt;/h1&gt; 
</code></pre>
<p>In the other hand if we don't ignore whitespaces:</p>
<pre><code class="language-handlebars">{{~# each users ~}}
    {{# if valid }}
        &lt;h1&gt;Hello, {{ name }}&lt;/h1&gt;
    {{/if }}
{{~/each}}
</code></pre>
<p>then this will be the output </p>
<pre><code class="language-text">
    &lt;h1&gt;Hello, Tom&lt;/h1&gt; 
    
</code></pre>
<h2><a class="header" href="#special-cases" id="special-cases">Special cases</a></h2>
<p>The are some especial cases where Yarte will ignore whitespaces before and after in some special cases by 
default. These cases are when writing <code>comments</code>, <code>locals</code>(such as <code>let</code> expressions), and whitespaces at 
the end of the file</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                        

                        

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                

                
            </nav>

        </div>

        

        

        
        
        
        <script type="text/javascript">
            window.playpen_copyable = true;
        </script>
        

        

        
        <script src="elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="searcher.js" type="text/javascript" charset="utf-8"></script>
        

        <script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
        

        
        
        <script type="text/javascript">
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>
        
        

    </body>
</html>
